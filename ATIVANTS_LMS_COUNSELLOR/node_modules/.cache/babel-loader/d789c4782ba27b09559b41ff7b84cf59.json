{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _styledComponents = _interopRequireWildcard(require(\"styled-components\"));\n\nvar _unsupportedView = _interopRequireDefault(require(\"./defaults/unsupported-view\"));\n\nvar _errorView = _interopRequireDefault(require(\"./defaults/error-view\"));\n\nvar _disconnectedView = _interopRequireDefault(require(\"./defaults/disconnected-view\"));\n\nvar _loadingView = _interopRequireDefault(require(\"./defaults/loading-view\"));\n\nvar _renderActions = _interopRequireDefault(require(\"./defaults/render-actions\"));\n\nvar _getVideoInfo = _interopRequireWildcard(require(\"./get-video-info\"));\n\nvar _customErrors = require(\"./custom-errors\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar MIME_TYPES = ['video/webm;codecs=\"vp8,opus\"', 'video/webm;codecs=h264', 'video/webm;codecs=vp9', 'video/webm'];\nvar CONSTRAINTS = {\n  audio: true,\n  video: true\n};\n\nvar Wrapper = _styledComponents[\"default\"].div.withConfig({\n  displayName: \"video-recorder__Wrapper\",\n  componentId: \"sc-7k20rv-0\"\n})([\"position:relative;display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;height:100%;overflow:hidden;min-height:300px;background-color:#000;color:white;box-sizing:border-box;*{box-sizing:inherit;}\"]);\n\nvar CameraView = _styledComponents[\"default\"].div.withConfig({\n  displayName: \"video-recorder__CameraView\",\n  componentId: \"sc-7k20rv-1\"\n})([\"width:100%;height:100%;\"]);\n\nvar Video = _styledComponents[\"default\"].video.withConfig({\n  displayName: \"video-recorder__Video\",\n  componentId: \"sc-7k20rv-2\"\n})([\"position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);min-height:100%;min-width:100%;width:100%;height:100%;object-fit:cover;\", \";\", \";\"], function (props) {\n  return props.isFlipped && (0, _styledComponents.css)([\"transform:translate(-50%,-50%) scaleX(-1);\"]);\n}, function (props) {\n  return props.onClick && (0, _styledComponents.css)([\"cursor:pointer;\"]);\n});\n\nvar VideoRecorder = /*#__PURE__*/function (_Component) {\n  _inherits(VideoRecorder, _Component);\n\n  function VideoRecorder() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, VideoRecorder);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(VideoRecorder)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"videoInput\", _react[\"default\"].createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"timeSinceInactivity\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      isRecording: false,\n      isCameraOn: false,\n      isConnecting: false,\n      isReplayingVideo: false,\n      isReplayVideoMuted: true,\n      thereWasAnError: false,\n      error: null,\n      streamIsReady: false,\n      isInlineRecordingSupported: null,\n      isVideoInputSupported: null,\n      stream: undefined\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"turnOnCamera\", function () {\n      if (_this.props.onTurnOnCamera) {\n        _this.props.onTurnOnCamera();\n      }\n\n      _this.setState({\n        isConnecting: true,\n        isReplayingVideo: false,\n        thereWasAnError: false,\n        error: null\n      });\n\n      var fallbackContraints = {\n        audio: true,\n        video: true\n      };\n      navigator.mediaDevices.getUserMedia(_this.props.constraints)[\"catch\"](function (err) {\n        // there's a bug in chrome in some windows computers where using `ideal` in the constraints throws a NotReadableError\n        if (err.name === 'NotReadableError' || err.name === 'OverconstrainedError') {\n          console.warn(\"Got \".concat(err.name, \", trying getUserMedia again with fallback constraints\"));\n          return navigator.mediaDevices.getUserMedia(fallbackContraints);\n        }\n\n        throw err;\n      }).then(_this.handleSuccess)[\"catch\"](_this.handleError);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"turnOffCamera\", function () {\n      if (_this.props.onTurnOffCamera) {\n        _this.props.onTurnOffCamera();\n      }\n\n      _this.stream && _this.stream.getTracks().forEach(function (stream) {\n        return stream.stop();\n      });\n\n      _this.setState({\n        isCameraOn: false\n      });\n\n      clearInterval(_this.inactivityTimer);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleSuccess\", function (stream) {\n      _this.stream = stream;\n\n      _this.setState({\n        isCameraOn: true,\n        stream: stream\n      });\n\n      if (_this.props.onCameraOn) {\n        _this.props.onCameraOn();\n      }\n\n      if (window.URL) {\n        _this.cameraVideo.srcObject = stream;\n      } else {\n        _this.cameraVideo.src = stream;\n      } // there is probably a better way\n      // but this makes sure the start recording button\n      // gives the stream a couple miliseconds to be ready\n\n\n      setTimeout(function () {\n        _this.setState({\n          isConnecting: false,\n          streamIsReady: true\n        });\n      }, 200);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleError\", function (err) {\n      var onError = _this.props.onError;\n      console.error('Captured error', err);\n      clearTimeout(_this.timeLimitTimeout);\n\n      if (onError) {\n        onError(err);\n      }\n\n      _this.setState({\n        isConnecting: _this.state.isConnecting && false,\n        isRecording: false,\n        thereWasAnError: true,\n        error: err\n      });\n\n      if (_this.state.isCameraOn) {\n        _this.turnOffCamera();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleDataIssue\", function (event) {\n      var error = new _customErrors.ReactVideoRecorderDataIssueError(event);\n      console.error(error.message, event);\n\n      _this.handleError(error);\n\n      return false;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getMimeType\", function () {\n      if (_this.props.mimeType) {\n        return _this.props.mimeType;\n      }\n\n      var mimeType = window.MediaRecorder.isTypeSupported ? MIME_TYPES.find(window.MediaRecorder.isTypeSupported) : 'video/webm';\n      return mimeType || '';\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"isDataHealthOK\", function (event) {\n      if (!event.data) return _this.handleDataIssue(event);\n      var chunkSize = _this.props.chunkSize;\n      var dataCheckInterval = 2000 / chunkSize; // in some browsers (FF/S), data only shows up\n      // after a certain amount of time ~everyt 2 seconds\n\n      var blobCount = _this.recordedBlobs.length;\n\n      if (blobCount > dataCheckInterval && blobCount % dataCheckInterval === 0) {\n        var blob = new window.Blob(_this.recordedBlobs, {\n          type: _this.getMimeType()\n        });\n        if (blob.size <= 0) return _this.handleDataIssue(event);\n      }\n\n      return true;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"tryToUnmuteReplayVideo\", function () {\n      var video = _this.replayVideo;\n      video.muted = false;\n      var playPromise = video.play();\n\n      if (!playPromise) {\n        video.muted = true;\n        return;\n      }\n\n      playPromise.then(function () {\n        _this.setState({\n          isReplayVideoMuted: false\n        }); // fixes bug where seeking control during autoplay is not available until the video is almost completely played through\n\n\n        if (_this.props.replayVideoAutoplayAndLoopOff) {\n          video.pause();\n          video.loop = false;\n        }\n      })[\"catch\"](function (err) {\n        console.warn('Could not autoplay replay video', err);\n        video.muted = true;\n        return video.play();\n      })[\"catch\"](function (err) {\n        console.warn('Could play muted replay video after failed autoplay', err);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleDataAvailable\", function (event) {\n      if (_this.isDataHealthOK(event)) {\n        _this.recordedBlobs.push(event.data);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleStopRecording\", function () {\n      if (_this.props.onStopRecording) {\n        _this.props.onStopRecording();\n      }\n\n      if (!_this.mediaRecorder) {\n        _this.handleError(new _customErrors.ReactVideoRecorderMediaRecorderUnavailableError());\n\n        return;\n      }\n\n      _this.mediaRecorder.stop();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handlePauseRecording\", function () {\n      if (_this.props.onPauseRecording) {\n        _this.props.onPauseRecording();\n      }\n\n      if (!_this.mediaRecorder) {\n        _this.handleError(new _customErrors.ReactVideoRecorderMediaRecorderUnavailableError());\n\n        return;\n      }\n\n      _this.mediaRecorder.pause();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleResumeRecording\", function () {\n      if (_this.props.onResumeRecording) {\n        _this.props.onResumeRecording();\n      }\n\n      if (!_this.mediaRecorder) {\n        _this.handleError(new _customErrors.ReactVideoRecorderMediaRecorderUnavailableError());\n\n        return;\n      }\n\n      _this.mediaRecorder.resume();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleStartRecording\", function () {\n      if (_this.props.onStartRecording) {\n        _this.props.onStartRecording();\n      }\n\n      _this.setState({\n        isRunningCountdown: true,\n        isReplayingVideo: false\n      });\n\n      setTimeout(function () {\n        return _this.startRecording();\n      }, _this.props.countdownTime);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"startRecording\", function () {\n      (0, _getVideoInfo.captureThumb)(_this.cameraVideo).then(function (thumbnail) {\n        _this.thumbnail = thumbnail;\n        _this.recordedBlobs = [];\n        var options = {\n          mimeType: _this.getMimeType()\n        };\n\n        try {\n          _this.setState({\n            isRunningCountdown: false,\n            isRecording: true\n          });\n\n          _this.startedAt = new Date().getTime();\n          _this.mediaRecorder = new window.MediaRecorder(_this.stream, options);\n\n          _this.mediaRecorder.addEventListener('stop', _this.handleStop);\n\n          _this.mediaRecorder.addEventListener('error', _this.handleError);\n\n          _this.mediaRecorder.addEventListener('dataavailable', _this.handleDataAvailable);\n\n          var _this$props = _this.props,\n              timeLimit = _this$props.timeLimit,\n              chunkSize = _this$props.chunkSize,\n              dataAvailableTimeout = _this$props.dataAvailableTimeout;\n\n          _this.mediaRecorder.start(chunkSize); // collect 10ms of data\n\n\n          if (timeLimit) {\n            _this.timeLimitTimeout = setTimeout(function () {\n              _this.handleStopRecording();\n            }, timeLimit);\n          } // mediaRecorder.ondataavailable should be called every 10ms,\n          // as that's what we're passing to mediaRecorder.start() above\n\n\n          if (Number.isInteger(dataAvailableTimeout)) {\n            setTimeout(function () {\n              if (_this.recordedBlobs.length === 0) {\n                _this.handleError(new _customErrors.ReactVideoRecorderDataAvailableTimeoutError(dataAvailableTimeout));\n              }\n            }, dataAvailableTimeout);\n          }\n        } catch (err) {\n          console.error(\"Couldn't create MediaRecorder\", err, options);\n\n          _this.handleError(err);\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleStop\", function (event) {\n      var endedAt = new Date().getTime();\n\n      if (!_this.recordedBlobs || _this.recordedBlobs.length <= 0) {\n        var error = new _customErrors.ReactVideoRecorderRecordedBlobsUnavailableError(event);\n        console.error(error.message, event);\n\n        _this.handleError(error);\n\n        return;\n      }\n\n      clearTimeout(_this.timeLimitTimeout);\n      var videoBlob = _this.recordedBlobs.length === 1 ? _this.recordedBlobs[0] : new window.Blob(_this.recordedBlobs, {\n        type: _this.getMimeType()\n      });\n      var thumbnailBlob = _this.thumbnail;\n      var startedAt = _this.startedAt;\n      var duration = endedAt - startedAt; // if this gets executed too soon, the last chunk of data is lost on FF\n\n      _this.mediaRecorder.ondataavailable = null;\n\n      _this.setState({\n        isRecording: false,\n        isReplayingVideo: true,\n        isReplayVideoMuted: true,\n        videoBlob: videoBlob,\n        videoUrl: window.URL.createObjectURL(videoBlob)\n      });\n\n      _this.turnOffCamera();\n\n      _this.props.onRecordingComplete(videoBlob, startedAt, thumbnailBlob, duration);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleVideoSelected\", function (e) {\n      if (_this.state.isReplayingVideo) {\n        _this.setState({\n          isReplayingVideo: false\n        });\n      }\n\n      var files = e.target.files || e.dataTransfer.files;\n      if (files.length === 0) return;\n      var startedAt = new Date().getTime();\n      var video = files[0];\n      e.target.value = null;\n      var extension = video.type === 'video/quicktime' ? 'mov' : undefined;\n      (0, _getVideoInfo[\"default\"])(video).then(function (_ref) {\n        var duration = _ref.duration,\n            thumbnail = _ref.thumbnail;\n\n        _this.setState({\n          isRecording: false,\n          isReplayingVideo: true,\n          isReplayVideoMuted: true,\n          videoBlob: video,\n          videoUrl: window.URL.createObjectURL(video)\n        });\n\n        _this.props.onRecordingComplete(video, startedAt, thumbnail, duration, extension);\n      })[\"catch\"](function (err) {\n        _this.handleError(err);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleOpenVideoInput\", function () {\n      if (_this.props.onOpenVideoInput) {\n        _this.props.onOpenVideoInput();\n      }\n\n      _this.videoInput.current.value = null;\n\n      _this.videoInput.current.click();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleStopReplaying\", function () {\n      if (_this.props.onStopReplaying) {\n        _this.props.onStopReplaying();\n      }\n\n      if (_this.props.useVideoInput && _this.props.isOnInitially) {\n        return _this.handleOpenVideoInput();\n      }\n\n      _this.setState({\n        isReplayingVideo: false\n      });\n\n      if (_this.state.isInlineRecordingSupported && _this.props.isOnInitially) {\n        _this.turnOnCamera();\n      } else if (_this.state.isVideoInputSupported && _this.props.isOnInitially) {\n        _this.handleOpenVideoInput();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleReplayVideoClick\", function () {\n      if (_this.replayVideo.paused && !_this.props.showReplayControls) {\n        _this.replayVideo.play();\n      } // fixes bug where seeking control during autoplay is not available until the video is almost completely played through\n\n\n      if (!_this.props.replayVideoAutoplayAndLoopOff) {\n        _this.setState({\n          isReplayVideoMuted: !_this.state.isReplayVideoMuted\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleDurationChange\", function () {\n      if (_this.props.showReplayControls) {\n        _this.replayVideo.currentTime = 1000000;\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(VideoRecorder, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var isInlineRecordingSupported = !!window.MediaSource && !!window.MediaRecorder && !!navigator.mediaDevices;\n      var isVideoInputSupported = document.createElement('input').capture !== undefined;\n\n      if (isInlineRecordingSupported) {\n        this.mediaSource = new window.MediaSource();\n      }\n\n      this.setState({\n        isInlineRecordingSupported: isInlineRecordingSupported,\n        isVideoInputSupported: isVideoInputSupported\n      }, function () {\n        if (_this2.props.useVideoInput && _this2.props.isOnInitially) {\n          _this2.handleOpenVideoInput();\n        } else if (_this2.state.isInlineRecordingSupported && _this2.props.isOnInitially) {\n          _this2.turnOnCamera();\n        } else if (_this2.state.isVideoInputSupported && _this2.props.isOnInitially) {\n          _this2.handleOpenVideoInput();\n        }\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (this.replayVideo && this.state.isReplayingVideo && !prevState.isReplayingVideo) {\n        this.tryToUnmuteReplayVideo();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.turnOffCamera();\n    }\n  }, {\n    key: \"renderCameraView\",\n    value: function renderCameraView() {\n      var _this3 = this;\n\n      var _this$props2 = this.props,\n          showReplayControls = _this$props2.showReplayControls,\n          replayVideoAutoplayAndLoopOff = _this$props2.replayVideoAutoplayAndLoopOff,\n          renderDisconnectedView = _this$props2.renderDisconnectedView,\n          renderVideoInputView = _this$props2.renderVideoInputView,\n          renderUnsupportedView = _this$props2.renderUnsupportedView,\n          renderErrorView = _this$props2.renderErrorView,\n          renderLoadingView = _this$props2.renderLoadingView,\n          useVideoInput = _this$props2.useVideoInput;\n      var _this$state = this.state,\n          isVideoInputSupported = _this$state.isVideoInputSupported,\n          isReplayingVideo = _this$state.isReplayingVideo,\n          isInlineRecordingSupported = _this$state.isInlineRecordingSupported,\n          thereWasAnError = _this$state.thereWasAnError,\n          error = _this$state.error,\n          isCameraOn = _this$state.isCameraOn,\n          isConnecting = _this$state.isConnecting,\n          isReplayVideoMuted = _this$state.isReplayVideoMuted;\n      var shouldUseVideoInput = useVideoInput || !isInlineRecordingSupported && isVideoInputSupported;\n      var videoInput = shouldUseVideoInput ? _react[\"default\"].createElement(\"input\", {\n        ref: this.videoInput,\n        key: \"videoInput\",\n        type: \"file\",\n        accept: \"video/*\",\n        capture: useVideoInput ? undefined : 'user',\n        style: {\n          display: 'none'\n        },\n        onChange: this.handleVideoSelected\n      }) : null;\n\n      if (isReplayingVideo) {\n        return _react[\"default\"].createElement(CameraView, {\n          key: \"replay\"\n        }, _react[\"default\"].createElement(Video, {\n          ref: function ref(el) {\n            return _this3.replayVideo = el;\n          },\n          src: this.state.videoUrl,\n          loop: true,\n          muted: isReplayVideoMuted,\n          playsInline: true,\n          autoPlay: !replayVideoAutoplayAndLoopOff,\n          controls: showReplayControls,\n          onClick: this.handleReplayVideoClick,\n          onDurationChange: this.handleDurationChange\n        }), videoInput);\n      }\n\n      if (shouldUseVideoInput) {\n        return renderVideoInputView({\n          videoInput: videoInput\n        });\n      }\n\n      if (!isInlineRecordingSupported) {\n        return renderUnsupportedView();\n      }\n\n      if (thereWasAnError) {\n        return renderErrorView({\n          error: error\n        });\n      }\n\n      if (isCameraOn) {\n        return _react[\"default\"].createElement(CameraView, {\n          key: \"camera\"\n        }, _react[\"default\"].createElement(Video, {\n          isFlipped: this.props.isFlipped,\n          ref: function ref(el) {\n            return _this3.cameraVideo = el;\n          },\n          autoPlay: true,\n          muted: true\n        }));\n      }\n\n      if (isConnecting) {\n        return renderLoadingView();\n      }\n\n      return renderDisconnectedView();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$state2 = this.state,\n          isVideoInputSupported = _this$state2.isVideoInputSupported,\n          isInlineRecordingSupported = _this$state2.isInlineRecordingSupported,\n          thereWasAnError = _this$state2.thereWasAnError,\n          isRecording = _this$state2.isRecording,\n          isCameraOn = _this$state2.isCameraOn,\n          streamIsReady = _this$state2.streamIsReady,\n          isConnecting = _this$state2.isConnecting,\n          isRunningCountdown = _this$state2.isRunningCountdown,\n          isReplayingVideo = _this$state2.isReplayingVideo,\n          isReplayVideoMuted = _this$state2.isReplayVideoMuted;\n      var _this$props3 = this.props,\n          countdownTime = _this$props3.countdownTime,\n          timeLimit = _this$props3.timeLimit,\n          showReplayControls = _this$props3.showReplayControls,\n          replayVideoAutoplayAndLoopOff = _this$props3.replayVideoAutoplayAndLoopOff,\n          renderActions = _this$props3.renderActions,\n          useVideoInput = _this$props3.useVideoInput;\n      return _react[\"default\"].createElement(Wrapper, null, this.renderCameraView(), renderActions({\n        isVideoInputSupported: isVideoInputSupported,\n        isInlineRecordingSupported: isInlineRecordingSupported,\n        thereWasAnError: thereWasAnError,\n        isRecording: isRecording,\n        isCameraOn: isCameraOn,\n        streamIsReady: streamIsReady,\n        isConnecting: isConnecting,\n        isRunningCountdown: isRunningCountdown,\n        isReplayingVideo: isReplayingVideo,\n        isReplayVideoMuted: isReplayVideoMuted,\n        countdownTime: countdownTime,\n        timeLimit: timeLimit,\n        showReplayControls: showReplayControls,\n        replayVideoAutoplayAndLoopOff: replayVideoAutoplayAndLoopOff,\n        useVideoInput: useVideoInput,\n        onTurnOnCamera: this.turnOnCamera,\n        onTurnOffCamera: this.turnOffCamera,\n        onOpenVideoInput: this.handleOpenVideoInput,\n        onStartRecording: this.handleStartRecording,\n        onStopRecording: this.handleStopRecording,\n        onPauseRecording: this.handlePauseRecording,\n        onResumeRecording: this.handleResumeRecording,\n        onStopReplaying: this.handleStopReplaying\n      }));\n    }\n  }]);\n\n  return VideoRecorder;\n}(_react.Component);\n\nexports[\"default\"] = VideoRecorder;\n\n_defineProperty(VideoRecorder, \"propTypes\", {\n  /** Whether or not to start the camera initially */\n  isOnInitially: _propTypes[\"default\"].bool,\n\n  /** Whether or not to display the video flipped (makes sense for user facing camera) */\n  isFlipped: _propTypes[\"default\"].bool,\n\n  /** Pass this if you want to force a specific mime-type for the video */\n  mimeType: _propTypes[\"default\"].string,\n\n  /** How much time to wait until it starts recording (in ms) */\n  countdownTime: _propTypes[\"default\"].number,\n\n  /** Use this if you want to set a time limit for the video (in ms) */\n  timeLimit: _propTypes[\"default\"].number,\n\n  /** Use this if you want to show play/pause/etc. controls on the replay video */\n  showReplayControls: _propTypes[\"default\"].bool,\n\n  /** Use this to turn off autoplay and looping of the replay video. It is recommended to also showReplayControls in order to play */\n  replayVideoAutoplayAndLoopOff: _propTypes[\"default\"].bool,\n\n  /** Use this if you want to customize the constraints passed to getUserMedia() */\n  constraints: _propTypes[\"default\"].shape({\n    audio: _propTypes[\"default\"].any,\n    video: _propTypes[\"default\"].any\n  }),\n  chunkSize: _propTypes[\"default\"].number,\n  dataAvailableTimeout: _propTypes[\"default\"].number,\n  useVideoInput: _propTypes[\"default\"].bool,\n  renderDisconnectedView: _propTypes[\"default\"].func,\n  renderLoadingView: _propTypes[\"default\"].func,\n  renderVideoInputView: _propTypes[\"default\"].func,\n  renderUnsupportedView: _propTypes[\"default\"].func,\n  renderErrorView: _propTypes[\"default\"].func,\n  renderActions: _propTypes[\"default\"].func,\n  onCameraOn: _propTypes[\"default\"].func,\n  onTurnOnCamera: _propTypes[\"default\"].func,\n  onTurnOffCamera: _propTypes[\"default\"].func,\n  onStartRecording: _propTypes[\"default\"].func,\n  onStopRecording: _propTypes[\"default\"].func,\n  onPauseRecording: _propTypes[\"default\"].func,\n  onResumeRecording: _propTypes[\"default\"].func,\n  onRecordingComplete: _propTypes[\"default\"].func,\n  onOpenVideoInput: _propTypes[\"default\"].func,\n  onStopReplaying: _propTypes[\"default\"].func,\n  onError: _propTypes[\"default\"].func\n});\n\n_defineProperty(VideoRecorder, \"defaultProps\", {\n  renderUnsupportedView: function renderUnsupportedView() {\n    return _react[\"default\"].createElement(_unsupportedView[\"default\"], null);\n  },\n  renderErrorView: function renderErrorView() {\n    return _react[\"default\"].createElement(_errorView[\"default\"], null);\n  },\n  renderVideoInputView: function renderVideoInputView(_ref2) {\n    var videoInput = _ref2.videoInput;\n    return _react[\"default\"].createElement(_react[\"default\"].Fragment, null, videoInput);\n  },\n  renderDisconnectedView: function renderDisconnectedView() {\n    return _react[\"default\"].createElement(_disconnectedView[\"default\"], null);\n  },\n  renderLoadingView: function renderLoadingView() {\n    return _react[\"default\"].createElement(_loadingView[\"default\"], null);\n  },\n  renderActions: _renderActions[\"default\"],\n  isFlipped: true,\n  countdownTime: 3000,\n  constraints: CONSTRAINTS,\n  chunkSize: 250,\n  dataAvailableTimeout: 500\n});","map":{"version":3,"sources":["C:/Users/ACTIVANTS/Desktop/LMS Councellor/Activants_LMS_Counsellor/ATIVANTS_LMS_COUNSELLOR/node_modules/react-video-recorder/lib/video-recorder.js"],"names":["Object","defineProperty","exports","value","_react","_interopRequireWildcard","require","_propTypes","_interopRequireDefault","_styledComponents","_unsupportedView","_errorView","_disconnectedView","_loadingView","_renderActions","_getVideoInfo","_customErrors","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","_typeof","Symbol","iterator","constructor","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","_createClass","protoProps","staticProps","_possibleConstructorReturn","self","_assertThisInitialized","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","ReferenceError","_inherits","subClass","superClass","create","_setPrototypeOf","p","_defineProperty","MIME_TYPES","CONSTRAINTS","audio","video","Wrapper","div","withConfig","displayName","componentId","CameraView","Video","isFlipped","css","onClick","VideoRecorder","_Component","_getPrototypeOf2","_this","_len","arguments","args","Array","_key","apply","concat","createRef","isRecording","isCameraOn","isConnecting","isReplayingVideo","isReplayVideoMuted","thereWasAnError","error","streamIsReady","isInlineRecordingSupported","isVideoInputSupported","stream","undefined","onTurnOnCamera","setState","fallbackContraints","navigator","mediaDevices","getUserMedia","constraints","err","name","console","warn","then","handleSuccess","handleError","onTurnOffCamera","getTracks","forEach","stop","clearInterval","inactivityTimer","onCameraOn","window","URL","cameraVideo","srcObject","src","setTimeout","onError","clearTimeout","timeLimitTimeout","state","turnOffCamera","event","ReactVideoRecorderDataIssueError","message","mimeType","MediaRecorder","isTypeSupported","find","data","handleDataIssue","chunkSize","dataCheckInterval","blobCount","recordedBlobs","blob","Blob","type","getMimeType","size","replayVideo","muted","playPromise","play","replayVideoAutoplayAndLoopOff","pause","loop","isDataHealthOK","push","onStopRecording","mediaRecorder","ReactVideoRecorderMediaRecorderUnavailableError","onPauseRecording","onResumeRecording","resume","onStartRecording","isRunningCountdown","startRecording","countdownTime","captureThumb","thumbnail","options","startedAt","Date","getTime","addEventListener","handleStop","handleDataAvailable","_this$props","timeLimit","dataAvailableTimeout","start","handleStopRecording","Number","isInteger","ReactVideoRecorderDataAvailableTimeoutError","endedAt","ReactVideoRecorderRecordedBlobsUnavailableError","videoBlob","thumbnailBlob","duration","ondataavailable","videoUrl","createObjectURL","onRecordingComplete","e","files","dataTransfer","extension","_ref","onOpenVideoInput","videoInput","current","click","onStopReplaying","useVideoInput","isOnInitially","handleOpenVideoInput","turnOnCamera","paused","showReplayControls","currentTime","componentDidMount","_this2","MediaSource","document","createElement","capture","mediaSource","componentDidUpdate","prevProps","prevState","tryToUnmuteReplayVideo","componentWillUnmount","renderCameraView","_this3","_this$props2","renderDisconnectedView","renderVideoInputView","renderUnsupportedView","renderErrorView","renderLoadingView","_this$state","shouldUseVideoInput","ref","accept","style","display","onChange","handleVideoSelected","el","playsInline","autoPlay","controls","handleReplayVideoClick","onDurationChange","handleDurationChange","render","_this$state2","_this$props3","renderActions","handleStartRecording","handlePauseRecording","handleResumeRecording","handleStopReplaying","Component","bool","string","number","shape","any","func","_ref2","Fragment"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _styledComponents = _interopRequireWildcard(require(\"styled-components\"));\n\nvar _unsupportedView = _interopRequireDefault(require(\"./defaults/unsupported-view\"));\n\nvar _errorView = _interopRequireDefault(require(\"./defaults/error-view\"));\n\nvar _disconnectedView = _interopRequireDefault(require(\"./defaults/disconnected-view\"));\n\nvar _loadingView = _interopRequireDefault(require(\"./defaults/loading-view\"));\n\nvar _renderActions = _interopRequireDefault(require(\"./defaults/render-actions\"));\n\nvar _getVideoInfo = _interopRequireWildcard(require(\"./get-video-info\"));\n\nvar _customErrors = require(\"./custom-errors\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar MIME_TYPES = ['video/webm;codecs=\"vp8,opus\"', 'video/webm;codecs=h264', 'video/webm;codecs=vp9', 'video/webm'];\nvar CONSTRAINTS = {\n  audio: true,\n  video: true\n};\n\nvar Wrapper = _styledComponents[\"default\"].div.withConfig({\n  displayName: \"video-recorder__Wrapper\",\n  componentId: \"sc-7k20rv-0\"\n})([\"position:relative;display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;height:100%;overflow:hidden;min-height:300px;background-color:#000;color:white;box-sizing:border-box;*{box-sizing:inherit;}\"]);\n\nvar CameraView = _styledComponents[\"default\"].div.withConfig({\n  displayName: \"video-recorder__CameraView\",\n  componentId: \"sc-7k20rv-1\"\n})([\"width:100%;height:100%;\"]);\n\nvar Video = _styledComponents[\"default\"].video.withConfig({\n  displayName: \"video-recorder__Video\",\n  componentId: \"sc-7k20rv-2\"\n})([\"position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);min-height:100%;min-width:100%;width:100%;height:100%;object-fit:cover;\", \";\", \";\"], function (props) {\n  return props.isFlipped && (0, _styledComponents.css)([\"transform:translate(-50%,-50%) scaleX(-1);\"]);\n}, function (props) {\n  return props.onClick && (0, _styledComponents.css)([\"cursor:pointer;\"]);\n});\n\nvar VideoRecorder =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(VideoRecorder, _Component);\n\n  function VideoRecorder() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, VideoRecorder);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(VideoRecorder)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"videoInput\", _react[\"default\"].createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"timeSinceInactivity\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      isRecording: false,\n      isCameraOn: false,\n      isConnecting: false,\n      isReplayingVideo: false,\n      isReplayVideoMuted: true,\n      thereWasAnError: false,\n      error: null,\n      streamIsReady: false,\n      isInlineRecordingSupported: null,\n      isVideoInputSupported: null,\n      stream: undefined\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"turnOnCamera\", function () {\n      if (_this.props.onTurnOnCamera) {\n        _this.props.onTurnOnCamera();\n      }\n\n      _this.setState({\n        isConnecting: true,\n        isReplayingVideo: false,\n        thereWasAnError: false,\n        error: null\n      });\n\n      var fallbackContraints = {\n        audio: true,\n        video: true\n      };\n      navigator.mediaDevices.getUserMedia(_this.props.constraints)[\"catch\"](function (err) {\n        // there's a bug in chrome in some windows computers where using `ideal` in the constraints throws a NotReadableError\n        if (err.name === 'NotReadableError' || err.name === 'OverconstrainedError') {\n          console.warn(\"Got \".concat(err.name, \", trying getUserMedia again with fallback constraints\"));\n          return navigator.mediaDevices.getUserMedia(fallbackContraints);\n        }\n\n        throw err;\n      }).then(_this.handleSuccess)[\"catch\"](_this.handleError);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"turnOffCamera\", function () {\n      if (_this.props.onTurnOffCamera) {\n        _this.props.onTurnOffCamera();\n      }\n\n      _this.stream && _this.stream.getTracks().forEach(function (stream) {\n        return stream.stop();\n      });\n\n      _this.setState({\n        isCameraOn: false\n      });\n\n      clearInterval(_this.inactivityTimer);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleSuccess\", function (stream) {\n      _this.stream = stream;\n\n      _this.setState({\n        isCameraOn: true,\n        stream: stream\n      });\n\n      if (_this.props.onCameraOn) {\n        _this.props.onCameraOn();\n      }\n\n      if (window.URL) {\n        _this.cameraVideo.srcObject = stream;\n      } else {\n        _this.cameraVideo.src = stream;\n      } // there is probably a better way\n      // but this makes sure the start recording button\n      // gives the stream a couple miliseconds to be ready\n\n\n      setTimeout(function () {\n        _this.setState({\n          isConnecting: false,\n          streamIsReady: true\n        });\n      }, 200);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleError\", function (err) {\n      var onError = _this.props.onError;\n      console.error('Captured error', err);\n      clearTimeout(_this.timeLimitTimeout);\n\n      if (onError) {\n        onError(err);\n      }\n\n      _this.setState({\n        isConnecting: _this.state.isConnecting && false,\n        isRecording: false,\n        thereWasAnError: true,\n        error: err\n      });\n\n      if (_this.state.isCameraOn) {\n        _this.turnOffCamera();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleDataIssue\", function (event) {\n      var error = new _customErrors.ReactVideoRecorderDataIssueError(event);\n      console.error(error.message, event);\n\n      _this.handleError(error);\n\n      return false;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getMimeType\", function () {\n      if (_this.props.mimeType) {\n        return _this.props.mimeType;\n      }\n\n      var mimeType = window.MediaRecorder.isTypeSupported ? MIME_TYPES.find(window.MediaRecorder.isTypeSupported) : 'video/webm';\n      return mimeType || '';\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"isDataHealthOK\", function (event) {\n      if (!event.data) return _this.handleDataIssue(event);\n      var chunkSize = _this.props.chunkSize;\n      var dataCheckInterval = 2000 / chunkSize; // in some browsers (FF/S), data only shows up\n      // after a certain amount of time ~everyt 2 seconds\n\n      var blobCount = _this.recordedBlobs.length;\n\n      if (blobCount > dataCheckInterval && blobCount % dataCheckInterval === 0) {\n        var blob = new window.Blob(_this.recordedBlobs, {\n          type: _this.getMimeType()\n        });\n        if (blob.size <= 0) return _this.handleDataIssue(event);\n      }\n\n      return true;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"tryToUnmuteReplayVideo\", function () {\n      var video = _this.replayVideo;\n      video.muted = false;\n      var playPromise = video.play();\n\n      if (!playPromise) {\n        video.muted = true;\n        return;\n      }\n\n      playPromise.then(function () {\n        _this.setState({\n          isReplayVideoMuted: false\n        }); // fixes bug where seeking control during autoplay is not available until the video is almost completely played through\n\n\n        if (_this.props.replayVideoAutoplayAndLoopOff) {\n          video.pause();\n          video.loop = false;\n        }\n      })[\"catch\"](function (err) {\n        console.warn('Could not autoplay replay video', err);\n        video.muted = true;\n        return video.play();\n      })[\"catch\"](function (err) {\n        console.warn('Could play muted replay video after failed autoplay', err);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleDataAvailable\", function (event) {\n      if (_this.isDataHealthOK(event)) {\n        _this.recordedBlobs.push(event.data);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleStopRecording\", function () {\n      if (_this.props.onStopRecording) {\n        _this.props.onStopRecording();\n      }\n\n      if (!_this.mediaRecorder) {\n        _this.handleError(new _customErrors.ReactVideoRecorderMediaRecorderUnavailableError());\n\n        return;\n      }\n\n      _this.mediaRecorder.stop();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handlePauseRecording\", function () {\n      if (_this.props.onPauseRecording) {\n        _this.props.onPauseRecording();\n      }\n\n      if (!_this.mediaRecorder) {\n        _this.handleError(new _customErrors.ReactVideoRecorderMediaRecorderUnavailableError());\n\n        return;\n      }\n\n      _this.mediaRecorder.pause();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleResumeRecording\", function () {\n      if (_this.props.onResumeRecording) {\n        _this.props.onResumeRecording();\n      }\n\n      if (!_this.mediaRecorder) {\n        _this.handleError(new _customErrors.ReactVideoRecorderMediaRecorderUnavailableError());\n\n        return;\n      }\n\n      _this.mediaRecorder.resume();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleStartRecording\", function () {\n      if (_this.props.onStartRecording) {\n        _this.props.onStartRecording();\n      }\n\n      _this.setState({\n        isRunningCountdown: true,\n        isReplayingVideo: false\n      });\n\n      setTimeout(function () {\n        return _this.startRecording();\n      }, _this.props.countdownTime);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"startRecording\", function () {\n      (0, _getVideoInfo.captureThumb)(_this.cameraVideo).then(function (thumbnail) {\n        _this.thumbnail = thumbnail;\n        _this.recordedBlobs = [];\n        var options = {\n          mimeType: _this.getMimeType()\n        };\n\n        try {\n          _this.setState({\n            isRunningCountdown: false,\n            isRecording: true\n          });\n\n          _this.startedAt = new Date().getTime();\n          _this.mediaRecorder = new window.MediaRecorder(_this.stream, options);\n\n          _this.mediaRecorder.addEventListener('stop', _this.handleStop);\n\n          _this.mediaRecorder.addEventListener('error', _this.handleError);\n\n          _this.mediaRecorder.addEventListener('dataavailable', _this.handleDataAvailable);\n\n          var _this$props = _this.props,\n              timeLimit = _this$props.timeLimit,\n              chunkSize = _this$props.chunkSize,\n              dataAvailableTimeout = _this$props.dataAvailableTimeout;\n\n          _this.mediaRecorder.start(chunkSize); // collect 10ms of data\n\n\n          if (timeLimit) {\n            _this.timeLimitTimeout = setTimeout(function () {\n              _this.handleStopRecording();\n            }, timeLimit);\n          } // mediaRecorder.ondataavailable should be called every 10ms,\n          // as that's what we're passing to mediaRecorder.start() above\n\n\n          if (Number.isInteger(dataAvailableTimeout)) {\n            setTimeout(function () {\n              if (_this.recordedBlobs.length === 0) {\n                _this.handleError(new _customErrors.ReactVideoRecorderDataAvailableTimeoutError(dataAvailableTimeout));\n              }\n            }, dataAvailableTimeout);\n          }\n        } catch (err) {\n          console.error(\"Couldn't create MediaRecorder\", err, options);\n\n          _this.handleError(err);\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleStop\", function (event) {\n      var endedAt = new Date().getTime();\n\n      if (!_this.recordedBlobs || _this.recordedBlobs.length <= 0) {\n        var error = new _customErrors.ReactVideoRecorderRecordedBlobsUnavailableError(event);\n        console.error(error.message, event);\n\n        _this.handleError(error);\n\n        return;\n      }\n\n      clearTimeout(_this.timeLimitTimeout);\n      var videoBlob = _this.recordedBlobs.length === 1 ? _this.recordedBlobs[0] : new window.Blob(_this.recordedBlobs, {\n        type: _this.getMimeType()\n      });\n      var thumbnailBlob = _this.thumbnail;\n      var startedAt = _this.startedAt;\n      var duration = endedAt - startedAt; // if this gets executed too soon, the last chunk of data is lost on FF\n\n      _this.mediaRecorder.ondataavailable = null;\n\n      _this.setState({\n        isRecording: false,\n        isReplayingVideo: true,\n        isReplayVideoMuted: true,\n        videoBlob: videoBlob,\n        videoUrl: window.URL.createObjectURL(videoBlob)\n      });\n\n      _this.turnOffCamera();\n\n      _this.props.onRecordingComplete(videoBlob, startedAt, thumbnailBlob, duration);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleVideoSelected\", function (e) {\n      if (_this.state.isReplayingVideo) {\n        _this.setState({\n          isReplayingVideo: false\n        });\n      }\n\n      var files = e.target.files || e.dataTransfer.files;\n      if (files.length === 0) return;\n      var startedAt = new Date().getTime();\n      var video = files[0];\n      e.target.value = null;\n      var extension = video.type === 'video/quicktime' ? 'mov' : undefined;\n      (0, _getVideoInfo[\"default\"])(video).then(function (_ref) {\n        var duration = _ref.duration,\n            thumbnail = _ref.thumbnail;\n\n        _this.setState({\n          isRecording: false,\n          isReplayingVideo: true,\n          isReplayVideoMuted: true,\n          videoBlob: video,\n          videoUrl: window.URL.createObjectURL(video)\n        });\n\n        _this.props.onRecordingComplete(video, startedAt, thumbnail, duration, extension);\n      })[\"catch\"](function (err) {\n        _this.handleError(err);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleOpenVideoInput\", function () {\n      if (_this.props.onOpenVideoInput) {\n        _this.props.onOpenVideoInput();\n      }\n\n      _this.videoInput.current.value = null;\n\n      _this.videoInput.current.click();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleStopReplaying\", function () {\n      if (_this.props.onStopReplaying) {\n        _this.props.onStopReplaying();\n      }\n\n      if (_this.props.useVideoInput && _this.props.isOnInitially) {\n        return _this.handleOpenVideoInput();\n      }\n\n      _this.setState({\n        isReplayingVideo: false\n      });\n\n      if (_this.state.isInlineRecordingSupported && _this.props.isOnInitially) {\n        _this.turnOnCamera();\n      } else if (_this.state.isVideoInputSupported && _this.props.isOnInitially) {\n        _this.handleOpenVideoInput();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleReplayVideoClick\", function () {\n      if (_this.replayVideo.paused && !_this.props.showReplayControls) {\n        _this.replayVideo.play();\n      } // fixes bug where seeking control during autoplay is not available until the video is almost completely played through\n\n\n      if (!_this.props.replayVideoAutoplayAndLoopOff) {\n        _this.setState({\n          isReplayVideoMuted: !_this.state.isReplayVideoMuted\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleDurationChange\", function () {\n      if (_this.props.showReplayControls) {\n        _this.replayVideo.currentTime = 1000000;\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(VideoRecorder, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var isInlineRecordingSupported = !!window.MediaSource && !!window.MediaRecorder && !!navigator.mediaDevices;\n      var isVideoInputSupported = document.createElement('input').capture !== undefined;\n\n      if (isInlineRecordingSupported) {\n        this.mediaSource = new window.MediaSource();\n      }\n\n      this.setState({\n        isInlineRecordingSupported: isInlineRecordingSupported,\n        isVideoInputSupported: isVideoInputSupported\n      }, function () {\n        if (_this2.props.useVideoInput && _this2.props.isOnInitially) {\n          _this2.handleOpenVideoInput();\n        } else if (_this2.state.isInlineRecordingSupported && _this2.props.isOnInitially) {\n          _this2.turnOnCamera();\n        } else if (_this2.state.isVideoInputSupported && _this2.props.isOnInitially) {\n          _this2.handleOpenVideoInput();\n        }\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (this.replayVideo && this.state.isReplayingVideo && !prevState.isReplayingVideo) {\n        this.tryToUnmuteReplayVideo();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.turnOffCamera();\n    }\n  }, {\n    key: \"renderCameraView\",\n    value: function renderCameraView() {\n      var _this3 = this;\n\n      var _this$props2 = this.props,\n          showReplayControls = _this$props2.showReplayControls,\n          replayVideoAutoplayAndLoopOff = _this$props2.replayVideoAutoplayAndLoopOff,\n          renderDisconnectedView = _this$props2.renderDisconnectedView,\n          renderVideoInputView = _this$props2.renderVideoInputView,\n          renderUnsupportedView = _this$props2.renderUnsupportedView,\n          renderErrorView = _this$props2.renderErrorView,\n          renderLoadingView = _this$props2.renderLoadingView,\n          useVideoInput = _this$props2.useVideoInput;\n      var _this$state = this.state,\n          isVideoInputSupported = _this$state.isVideoInputSupported,\n          isReplayingVideo = _this$state.isReplayingVideo,\n          isInlineRecordingSupported = _this$state.isInlineRecordingSupported,\n          thereWasAnError = _this$state.thereWasAnError,\n          error = _this$state.error,\n          isCameraOn = _this$state.isCameraOn,\n          isConnecting = _this$state.isConnecting,\n          isReplayVideoMuted = _this$state.isReplayVideoMuted;\n      var shouldUseVideoInput = useVideoInput || !isInlineRecordingSupported && isVideoInputSupported;\n      var videoInput = shouldUseVideoInput ? _react[\"default\"].createElement(\"input\", {\n        ref: this.videoInput,\n        key: \"videoInput\",\n        type: \"file\",\n        accept: \"video/*\",\n        capture: useVideoInput ? undefined : 'user',\n        style: {\n          display: 'none'\n        },\n        onChange: this.handleVideoSelected\n      }) : null;\n\n      if (isReplayingVideo) {\n        return _react[\"default\"].createElement(CameraView, {\n          key: \"replay\"\n        }, _react[\"default\"].createElement(Video, {\n          ref: function ref(el) {\n            return _this3.replayVideo = el;\n          },\n          src: this.state.videoUrl,\n          loop: true,\n          muted: isReplayVideoMuted,\n          playsInline: true,\n          autoPlay: !replayVideoAutoplayAndLoopOff,\n          controls: showReplayControls,\n          onClick: this.handleReplayVideoClick,\n          onDurationChange: this.handleDurationChange\n        }), videoInput);\n      }\n\n      if (shouldUseVideoInput) {\n        return renderVideoInputView({\n          videoInput: videoInput\n        });\n      }\n\n      if (!isInlineRecordingSupported) {\n        return renderUnsupportedView();\n      }\n\n      if (thereWasAnError) {\n        return renderErrorView({\n          error: error\n        });\n      }\n\n      if (isCameraOn) {\n        return _react[\"default\"].createElement(CameraView, {\n          key: \"camera\"\n        }, _react[\"default\"].createElement(Video, {\n          isFlipped: this.props.isFlipped,\n          ref: function ref(el) {\n            return _this3.cameraVideo = el;\n          },\n          autoPlay: true,\n          muted: true\n        }));\n      }\n\n      if (isConnecting) {\n        return renderLoadingView();\n      }\n\n      return renderDisconnectedView();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$state2 = this.state,\n          isVideoInputSupported = _this$state2.isVideoInputSupported,\n          isInlineRecordingSupported = _this$state2.isInlineRecordingSupported,\n          thereWasAnError = _this$state2.thereWasAnError,\n          isRecording = _this$state2.isRecording,\n          isCameraOn = _this$state2.isCameraOn,\n          streamIsReady = _this$state2.streamIsReady,\n          isConnecting = _this$state2.isConnecting,\n          isRunningCountdown = _this$state2.isRunningCountdown,\n          isReplayingVideo = _this$state2.isReplayingVideo,\n          isReplayVideoMuted = _this$state2.isReplayVideoMuted;\n      var _this$props3 = this.props,\n          countdownTime = _this$props3.countdownTime,\n          timeLimit = _this$props3.timeLimit,\n          showReplayControls = _this$props3.showReplayControls,\n          replayVideoAutoplayAndLoopOff = _this$props3.replayVideoAutoplayAndLoopOff,\n          renderActions = _this$props3.renderActions,\n          useVideoInput = _this$props3.useVideoInput;\n      return _react[\"default\"].createElement(Wrapper, null, this.renderCameraView(), renderActions({\n        isVideoInputSupported: isVideoInputSupported,\n        isInlineRecordingSupported: isInlineRecordingSupported,\n        thereWasAnError: thereWasAnError,\n        isRecording: isRecording,\n        isCameraOn: isCameraOn,\n        streamIsReady: streamIsReady,\n        isConnecting: isConnecting,\n        isRunningCountdown: isRunningCountdown,\n        isReplayingVideo: isReplayingVideo,\n        isReplayVideoMuted: isReplayVideoMuted,\n        countdownTime: countdownTime,\n        timeLimit: timeLimit,\n        showReplayControls: showReplayControls,\n        replayVideoAutoplayAndLoopOff: replayVideoAutoplayAndLoopOff,\n        useVideoInput: useVideoInput,\n        onTurnOnCamera: this.turnOnCamera,\n        onTurnOffCamera: this.turnOffCamera,\n        onOpenVideoInput: this.handleOpenVideoInput,\n        onStartRecording: this.handleStartRecording,\n        onStopRecording: this.handleStopRecording,\n        onPauseRecording: this.handlePauseRecording,\n        onResumeRecording: this.handleResumeRecording,\n        onStopReplaying: this.handleStopReplaying\n      }));\n    }\n  }]);\n\n  return VideoRecorder;\n}(_react.Component);\n\nexports[\"default\"] = VideoRecorder;\n\n_defineProperty(VideoRecorder, \"propTypes\", {\n  /** Whether or not to start the camera initially */\n  isOnInitially: _propTypes[\"default\"].bool,\n\n  /** Whether or not to display the video flipped (makes sense for user facing camera) */\n  isFlipped: _propTypes[\"default\"].bool,\n\n  /** Pass this if you want to force a specific mime-type for the video */\n  mimeType: _propTypes[\"default\"].string,\n\n  /** How much time to wait until it starts recording (in ms) */\n  countdownTime: _propTypes[\"default\"].number,\n\n  /** Use this if you want to set a time limit for the video (in ms) */\n  timeLimit: _propTypes[\"default\"].number,\n\n  /** Use this if you want to show play/pause/etc. controls on the replay video */\n  showReplayControls: _propTypes[\"default\"].bool,\n\n  /** Use this to turn off autoplay and looping of the replay video. It is recommended to also showReplayControls in order to play */\n  replayVideoAutoplayAndLoopOff: _propTypes[\"default\"].bool,\n\n  /** Use this if you want to customize the constraints passed to getUserMedia() */\n  constraints: _propTypes[\"default\"].shape({\n    audio: _propTypes[\"default\"].any,\n    video: _propTypes[\"default\"].any\n  }),\n  chunkSize: _propTypes[\"default\"].number,\n  dataAvailableTimeout: _propTypes[\"default\"].number,\n  useVideoInput: _propTypes[\"default\"].bool,\n  renderDisconnectedView: _propTypes[\"default\"].func,\n  renderLoadingView: _propTypes[\"default\"].func,\n  renderVideoInputView: _propTypes[\"default\"].func,\n  renderUnsupportedView: _propTypes[\"default\"].func,\n  renderErrorView: _propTypes[\"default\"].func,\n  renderActions: _propTypes[\"default\"].func,\n  onCameraOn: _propTypes[\"default\"].func,\n  onTurnOnCamera: _propTypes[\"default\"].func,\n  onTurnOffCamera: _propTypes[\"default\"].func,\n  onStartRecording: _propTypes[\"default\"].func,\n  onStopRecording: _propTypes[\"default\"].func,\n  onPauseRecording: _propTypes[\"default\"].func,\n  onResumeRecording: _propTypes[\"default\"].func,\n  onRecordingComplete: _propTypes[\"default\"].func,\n  onOpenVideoInput: _propTypes[\"default\"].func,\n  onStopReplaying: _propTypes[\"default\"].func,\n  onError: _propTypes[\"default\"].func\n});\n\n_defineProperty(VideoRecorder, \"defaultProps\", {\n  renderUnsupportedView: function renderUnsupportedView() {\n    return _react[\"default\"].createElement(_unsupportedView[\"default\"], null);\n  },\n  renderErrorView: function renderErrorView() {\n    return _react[\"default\"].createElement(_errorView[\"default\"], null);\n  },\n  renderVideoInputView: function renderVideoInputView(_ref2) {\n    var videoInput = _ref2.videoInput;\n    return _react[\"default\"].createElement(_react[\"default\"].Fragment, null, videoInput);\n  },\n  renderDisconnectedView: function renderDisconnectedView() {\n    return _react[\"default\"].createElement(_disconnectedView[\"default\"], null);\n  },\n  renderLoadingView: function renderLoadingView() {\n    return _react[\"default\"].createElement(_loadingView[\"default\"], null);\n  },\n  renderActions: _renderActions[\"default\"],\n  isFlipped: true,\n  countdownTime: 3000,\n  constraints: CONSTRAINTS,\n  chunkSize: 250,\n  dataAvailableTimeout: 500\n});"]},"metadata":{},"sourceType":"script"}